<!DOCTYPE html>
<link rel="stylesheet" href="../../_static/theme.css" type="text/css" /> 
<html xmlns="http://www.w3.org/1999/xhtml" >

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Shor’s algorithm &#8212; Experience Documentation 2.0 documentation</title>
<link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
<link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
<script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
        URL_ROOT: '../../',
        VERSION: '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE: true,
        SOURCELINK_SUFFIX: '.txt'
    };
</script>
<script type="text/javascript" src="../../_static/jquery.js"></script>
<script type="text/javascript" src="../../_static/underscore.js"></script>
<script type="text/javascript" src="../../_static/doctools.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Quantum Algorithms" href="../004-Quantum_Algorithms/060-Quantum_Algorithms.html" />
    <link rel="prev" title="Quantum Phase Estimation" href="100-Quantum Phase Estimation.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes"> 

    <link rel="stylesheet" href="../../_static/theme.css" type="text/css" />

</head>

<body>    <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html"><span><img src="../../_static/ibm-q.png"></span>
          Experience Documentation</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../user_guide.html">IBM Quantum Experience Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Shor’s algorithm</a><ul>
<li><a class="reference internal" href="#complexity-of-factoring"><strong>Complexity of factoring</strong>.</a></li>
<li><a class="reference internal" href="#period-finding"><strong>Period finding</strong>.﻿﻿ ﻿</a></li>
<li><a class="reference internal" href="#from-factoring-to-period-finding"><strong>From factoring to period finding</strong>.</a></li>
<li><a class="reference internal" href="#id1"><strong>Shor’s algorithm</strong>.</a></li>
<li><a class="reference internal" href="#reversible-classical-circuits"><strong>Reversible classical circuits</strong>.</a></li>
<li><a class="reference internal" href="#quantum-circuits-for-modular-multiplication"><strong>Quantum circuits for modular multiplication</strong>.</a></li>
<li><a class="reference internal" href="#controlled-operations-and-phase-estimation"><strong>﻿Controlled operations and phase estimation</strong>.﻿</a><ul>
<li><a class="reference internal" href="#id8">**</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="100-Quantum Phase Estimation.html" title="Previous Chapter: Quantum Phase Estimation"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Quantum Phase...</span>
    </a>
  </li>
  <li>
    <a href="../004-Quantum_Algorithms/060-Quantum_Algorithms.html" title="Next Chapter: Quantum Algorithms"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Quantum Algorithms &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../../_sources/full-user-guide/004-Quantum Algorithms/110-Shor&#39;s algorithm.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div> 
<div class="container">
    <div class="row">
        <div class="col-md-12 content">
            
  <div class="section" id="shor-s-algorithm">
<h1>Shor’s algorithm<a class="headerlink" href="#shor-s-algorithm" title="Permalink to this headline">¶</a></h1>
<div class="line-block">
<div class="line">Although any integer number has a unique decomposition into a product
of primes, finding the prime factors is believed to be a hard&nbsp;problem.
In fact, the security of our online transactions rests on the
assumption that&nbsp;factoring integers with a thousand or more digits is
practically impossible.&nbsp;This assumption has been challenged in 1995
when Peter Shor proposed a polynomial-time quantum&nbsp;algorithm for the
factoring problem. Shor’s algorithm is arguably the most dramatic
example of how the paradigm of quantum computing changed our
perception of which problems should be considered tractable. In this
section we briefly summarize some basic facts about factoring,
highlight&nbsp;main ingredients of the Shor’s algorithm,&nbsp;and illustrate how
it works using a toy factoring problem.</div>
</div>
<div class="section" id="complexity-of-factoring">
<h2><strong>Complexity of factoring</strong>.<a class="headerlink" href="#complexity-of-factoring" title="Permalink to this headline">¶</a></h2>
<p>Suppose our task is to factor an integer $$N$$ with $$d$$ decimal
digits. The brute force algorithm&nbsp;goes through all primes $$p$$ up to
$$\sqrt{N}$$ and checks whether $$p$$ divides $$N$$.&nbsp;In the worst case,
this would take time roughly $$\sqrt{N}$$ which is exponential in the
number of digits $$d$$. &nbsp;A more efficient algorithm known as the
quadratic sieve attempts to construct integers $$a,b$$ such that
$$a^2-b^2$$ is a multiple of $$N$$.&nbsp;Once such $$a,b$$ are found, one
checks whether $$a\pm b$$ have common factors with $$N$$. &nbsp;The
quadratic sieve method has asymptotic runtime exponential in
$$\sqrt{d}$$. The most efficient classical factoring algorithm known as
general number field sieve&nbsp;achieves an asymptotic runtime exponential in
$$d^{1/3}$$. &nbsp;The exponential runtime scaling limits applicability of
the classical factoring algorithms&nbsp;to numbers with a few hundred digits
&nbsp;with the world record being $$d=232$$ (which took roughly 2,000 CPU
years). &nbsp;In contrast, Shor’s factoring algorithm has runtime
<em>polynomial</em> in $$d$$. The&nbsp;version of the algorithm described below due
to Alexey Kitaev&nbsp;requires roughly $$10d$$ qubits and has runtime
&nbsp;roughly $$d^3$$.</p>
<p><img alt="image0" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-figure1l0qpbqeb138fr.png" />&nbsp; &nbsp; **&nbsp;**</p>
<div class="line-block">
<div class="line"><strong>Figure 1: classical vs quantum factoring algorithms</strong></div>
</div>
</div>
<div class="section" id="period-finding">
<h2><strong>Period finding</strong>.﻿﻿ ﻿<a class="headerlink" href="#period-finding" title="Permalink to this headline">¶</a></h2>
<p>It has been known to mathematicians since 1970’s that factoring becomes
easy if one can solve another hard problem: find a period&nbsp;of the modular
exponential function. The period finding problem is defined as
follows.&nbsp;Given integers $$N$$ and $$a$$, find the smallest positive
integer $$r$$ &nbsp;such that $$a^r-1$$ is a multiple of $$N$$. The number
$$r$$ is called the period of $$a$$ modulo $$N$$.&nbsp;Recall that in modular
arithmetics the remainder of a division $$a/N$$ is called the value of
$$a$$ modulo $$N$$ and denoted $$a\pmod{N}$$. For example, $$1=16=91
\pmod{15}$$. Thus the period of $$a$$ modulo $$N$$ is the smallest
positive integer $$r$$ such that $$a^r=1{\pmod N}$$. For example,
suppose $$N=15$$ and $$a=7$$. Then</p>
<div class="line-block">
<div class="line"><img alt="image1" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-equation3fjaulqz4sqe3766r.png" /></div>
</div>
<p>that is, $$7$$ has period $$4$$ modulo $$15$$. Note that computing the
higher powers of $$7$$ would give rise to a periodic sequence:
$$7^{x+4}=7^x\pmod{15}$$ for any integer $$x$$. Thus $$r=4$$ is the
period of the modular exponential function $$7^x$$. &nbsp;In general the
period finding problem is well-defined if $$N$$ and $$a$$ are co-prime
(have no common factors).</p>
</div>
<div class="section" id="from-factoring-to-period-finding">
<h2><strong>From factoring to period finding</strong>.<a class="headerlink" href="#from-factoring-to-period-finding" title="Permalink to this headline">¶</a></h2>
<p>Assume for a moment that we are given a period finding machine that
takes as input co-prime integers $$N,a$$ and outputs the period of $$a$$
modulo $$N$$. Let us show how to use the machine to find all prime
factors of $$N$$. For simplicity, assume that $$N$$ has only two
distinct prime factors:</p>
<div class="line-block">
<div class="line"><img alt="image2" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-equation21ma2bwliskjd1jor.png" /></div>
</div>
<p>First, pick a random integer $$a$$ between $$2$$ and $$N-1$$&nbsp;and compute
the greatest common divisor gcd$$(N,a)$$.&nbsp;This can be done very
efficiently using <a class="reference external" href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid’s
algorithm</a>.&nbsp;If we
are lucky, $$N$$ and $$a$$ have some common prime factors&nbsp;in which case
gcd$$(N,a)$$ equals $$p_1$$ or $$p_2$$, so we are done.&nbsp;From now on
let us assume that gcd$$(N,a)=1$$, that is, $$N$$ and $$a$$ are
co-prime.&nbsp;Let $$r$$ be the period of $$a$$ modulo $$N$$ computed by the
machine.&nbsp;Repeat the above steps with different random choices of $$a$$
until $$r$$ is even. &nbsp;It can be shown that a significant fraction of all
integers $$a$$ &nbsp;has even period,&nbsp;see Table 1 for examples, so on average
one needs only a few repetitions. &nbsp;At this point we have found some pair
$$r,a$$&nbsp;such that $$r$$ is even and $$r$$ is the smallest integer such
that $$a^r-1$$ is a multiple of $$N$$.&nbsp;Let us use the identity</p>
<div class="line-block">
<div class="line"><img alt="image3" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-equation1vm27qee4bcma38fr.png" /></div>
</div>
<div class="line-block">
<div class="line">The above shows that $$a^{r/2}-1$$ is not a multiple of $$N$$
(otherwise the period of $$a$$ would be $$r/2$$). Assume for a moment
that $$a^{r/2}+1$$ is not a multiple of $$N$$.&nbsp;Then neither of the
integers $$a^{r/2}\pm 1$$&nbsp;is a multiple of $$N$$, but their product
is. &nbsp;This is possible only if $$p_1$$ is a prime factor of
$$a^{r/2}-1$$&nbsp;and $$p_2$$ is a prime factor of $$a^{r/2}+1$$ (or vice
verse).&nbsp;Thus we can find $$p_1$$ and $$p_2$$ by computing
gcd$$(N,a^{r/2}\pm 1)$$, see Table 1 for examples. &nbsp;In the remaining
``unlucky” case when $$a^{r/2}+1$$ is a multiple of $$N$$&nbsp;we give up
and try a different integer $$a$$. &nbsp;For example, $$a=14$$ is the only
unlucky integer in Table 1.&nbsp;In general, &nbsp;it can be shown that the
unlucky integers $$a$$ are not too frequent, so on average only two
calls to the period finding machine&nbsp;are sufficient to factor $$N$$.</div>
</div>
<div class="line-block">
<div class="line"><img alt="image4" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-table9nl8715xk3d3rf6r.png" /></div>
<div class="line"><strong>Table 1: period of integers $$a$$ modulo $$15$$</strong></div>
</div>
</div>
<div class="section" id="id1">
<h2><strong>Shor’s algorithm</strong>.<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">Let us now show that a quantum computer can efficiently simulate&nbsp;the
period finding machine. &nbsp;As in the case of the<a class="reference external" href="/qstage/#/tutorial?sectionId=8443c4f713521c10b1a56a533958286b&amp;pageIndex=3">Deutsch-Jozsa
algorithm</a>,
we shall exploit quantum parallelism and constructive interference to
determine whether a complicated function has a certain&nbsp;global property
that cannot be learned by evaluating the function only at a few
points.&nbsp;However, instead of detecting the property of being a balanced
function, we seek to detect and measure&nbsp;periodicity of the modular
exponentiation function. The fact that interference makes it easier to
measure&nbsp;periodicity should not come as a big surprise. After all,
physicists routinely use scattering of electromagnetic waves&nbsp;and
interference measurements to determine periodicity of physical objects
such as crystal lattices. Likewise, Shor’s algorithm exploits
interference to measure periodicity of arithmetic objects.</div>
</div>
<p>Suppose we are given co-prime integers $$a,N$$. Our goal is compute the
period of $$a$$&nbsp;modulo $$N$$, that is, the smallest positive integer
$$r$$ such that $$a^r=1\pmod{N}$$.&nbsp;The basic idea is to construct a
unitary operator $$U_a$$ that implements the modular
multiplication&nbsp;function $$x\to ax \pmod{N}$$. It can be shown that
eigenvalues of $$U_a$$ are closely related to the period of $$a$$.
Namely, each eigenvalue of $$U_a$$ has a form $$e^{i\phi}$$, where
$$\phi=2\pi k/r$$&nbsp;for some integer $$k$$. Furthermore, as we saw in
the previous section, eigenvalues of certain unitary operators can be
measured efficiently using the phase estimation
algorithm.&nbsp;Unfortunately, inferring $$r$$ from the measured eigenvalues
of $$U_a$$&nbsp;is only possible if the eigenvalues are measured <em>exactly</em>
(or with an exponentially small precision).&nbsp;For example, factoring a
1,000-digit number would require measuring the eigenvalue of $$U_a$$
with a precision $$10^{-2000}$$.&nbsp;Such accuracy cannot be achieved by a
direct application of the phase estimation algorithm&nbsp;as this would
require too large pointer system.&nbsp;Here comes the main trick: we shall
estimate the eigenvalue of $$U_a$$ by&nbsp;applying&nbsp;the phase estimation
algorithm to a family of unitary operators $$U_b$$&nbsp;with
$$b=a,a^2,a^4,a^8$$ etc.&nbsp;We stop at $$b=a^{2^p}$$ with $$2^p\approx
N^2$$.&nbsp;Why does it work? The first observation is that &nbsp;all operators
$$U_b$$ are integer powers of $$U_a$$.&nbsp;Namely, if $$b=a^t$$ then
$$U_b=(U_a)^t$$.&nbsp;This implies that the operators $$U_b$$&nbsp;&nbsp;have the
same eigenvectors.&nbsp;In particular, eigenvalues of the entire family
$$U_b$$&nbsp;can be measured simultaneously. &nbsp;Second, implementing $$U_b$$
is as easy as implementing $$U_a$$ - one just need&nbsp;to precompute the
powers $$b=a,a^2,a^4,a^8,\ldots \pmod{N}$$ by the repeated squaring
method.&nbsp;Finally, even if the eigenvalues of $$U_b$$ are measured with a
poor precision (say 10%),&nbsp;each squaring of $$a$$ reduces the error in
the estimated eigenvalue of $$U_a$$ by&nbsp;a factor $$1/2$$. &nbsp;Indeed,
consider an eigenvector of $$U_a$$ with an eigenvalue
$$e^{i\phi}$$.&nbsp;If $$b=a^2$$ then the eigenvalue of $$U_b$$ is
$$e^{2i\phi}$$. If $$b=a^4$$ then the&nbsp;eigenvalue of $$U_b$$ &nbsp;is
$$e^{4i\phi}$$ etc. Thus we can estimate
$$\phi,2\phi,4\phi,\ldots,2^p\phi$$ with a constant precision (say
10%). We shall see that this&nbsp;is enough to estimate $$\phi$$ with a
precision roughly $$2^{-p}$$. &nbsp;For example, &nbsp;one can achieve a precision
$$10^{-2000}$$&nbsp;by a sequence of less than $$10^6$$ &nbsp;lousy measurements
of $$U_b$$ with an error 10%. Furthermore, it can be shown that
estimating a few randomly picked eigenvalues&nbsp;$$\phi=2\pi k/r$$ with a
precision less than $$1/N^2$$ is enough to determine the period $$r$$
exactly (the idea is to find the best rational approximation to the
estimate of $$k/r$$ using continued fractions).</p>
<p>In order to use the phase estimation algorithm we need to construct a
quantum circuit implementing the modular multiplication operator. By
analogy with classical algorithms that can link standard library
functions, a quantum algorithm is allowed to call classical subroutines,
for example a subroutine for computing the modular multiplication.
Importantly, before such classical subroutines are incorporated into a
quantum circuit, they must be transformed into a <a href="#id2"><span class="problematic" id="id3">*</span></a>reversible
form.&nbsp;<a href="#id4"><span class="problematic" id="id5">*</span></a>More precisely, a quantum algorithm can call a classical
subroutine only if it is compiled into a sequence of reversible logical
gates such as CNOT or Toffoli gate (in particular, the number of input
and output wires in each gate must be the same). The&nbsp;subroutine is
allowed to use a scratch memory similar to local variables used by the
standard library functions. However, once the subroutine is completed,
the scratch memory must be totally clean (say, all zeros).&nbsp;The reason is
that a quantum algorithm operates on coherent superpositions of
different classical states. Leaving information about the inputs or the
outputs in the scratch memory could potentially destroy quantum
coherence and prevent the algorithm from seeing interference between
different states. Since the notion of reversible classical circuits
&nbsp;plays an important role in the Shor’s algorithm and many other quantum
algorithms, below we briefly discuss methods for constructing such
circuits.</p>
</div>
<div class="section" id="reversible-classical-circuits">
<h2><strong>Reversible classical circuits</strong>.<a class="headerlink" href="#reversible-classical-circuits" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">An important insight made in 1973 by our IBM colleague Charles Bennett
is that any classical computation can be transformed into a reversible
form.&nbsp;How does it work?&nbsp;Suppose $$f(x)$$ represents some classical
computation that takes&nbsp;as input $$n$$-bit strings $$x$$ and outputs
$$m$$-bit strings $$f(x)$$. The first observation is that the answer
$$f(x)$$&nbsp;can be computed without erasing any intermediate data if we
are allowed to use some extra memory. Indeed, let us write down an
algorithm for computing $$f(x)$$ and compile it into a sequence of
elementary&nbsp;logical gates such as AND, OR, etc. For concreteness,
assume that each gate has two input wires and one output wire. &nbsp;Let
$$L$$ be the total number of gates. We shall extend the $$n$$-bit
memory storing the input $$x$$ by adding $$L$$ bits initialized by
zeros. These extra bits will serve as a scratch memory for storing
intermediate data.&nbsp;We shall write the output of the &nbsp;$$i$$-th gate to
the $$i$$-th bit of the scratch memory and keep the values of
the&nbsp;input bits. Once the computation is completed, the final answer
$$f(x)$$ is contained in some designated output register within the
scratch memory. The remaining part of the scratch memory contains some
“garbage” bit string $$g(x)$$ (intermediate data). &nbsp;Below we
illustrate how it works for the example when $$f(x)$$ computes the
3-bit Majority function.</div>
</div>
<div class="line-block">
<div class="line"><img alt="image5" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/majority-example6x8rb37gj64dkj4i.png" /></div>
</div>
<p>At this point the circuit is reversible as a whole, but its individual
gates are still irreversible. The next step is to transform each gate
into a reversible form. Consider as an example the AND gate with input
wires $$a,b$$ and output wire $$c$$ such that $$c=a\wedge b$$. Let us
define its reversible version R-AND. One of the output wires of R-AND
must carry the output bit $$c$$ of the standard AND gate. To avoid
losing information, R-AND must have at least two other output wires
(note that in the case $$c=0$$ there are three possible input strings:
$$ab=00,01,10$$). The simplest version of R-AND has three input wires
and three output wires as shown below.</p>
<div class="line-block">
<div class="line"><img alt="image6" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/and-circuit2u342pzqqlnv1jor.png" /></div>
</div>
<p>Here $$d$$ is a dummy input wire and $$\oplus$$ denotes XOR operation
(addition modulo two). The gate expects to receive inputs with $$d=0$$
in which case $$c=a\wedge b$$. If $$d=1$$ then the output data bit if
flipped. Note that all inputs of R-AND can be computed from its outputs
since $$d=c\oplus (a\wedge b)$$. Thus R-AND indeed acts reversibly
(technically, R-AND realizes a permutation on the set of 3-bit strings).
Note also that R-AND coincides with the <a class="reference external" href="/qstage/#/tutorial?sectionId=8443c4f713521c10b1a56a533958286b&amp;pageIndex=1">Toffoli
gate</a>.
The same construction can be applied to any other gate with two input
wires and one output wire. Namely, if a gate F computes some Boolean
function $$c=F(a,b)$$ then its reversible version R-F would map inputs
$$a,b,d$$ to outputs $$a,b,c$$ where $$c=d\oplus F(a,b)$$, see below.
Note that applying R-F twice implements the identity gate, that is, R-F
coincides with its own inverse.</p>
<div class="line-block">
<div class="line"><img alt="image7" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/rgatearl3s2mvkon4gqfr.png" /></div>
</div>
<p>Suppose the original circuit is described by a sequence of $$L$$ gates
$$F_1,\ldots,F_L$$. Replace each gate &nbsp;$$F_i$$ &nbsp;by its reversible
version $$G_i=R$$-$$F_i$$ constructed above. &nbsp;We shall connect the
dummy input wire of $$G_i$$ and its output wire $$c$$ to the $$i$$-th
bit of the scratch memory such that the gate always receives inputs with
$$d=0$$. The new circuit has $$n+L$$ input and $$n+L$$ output wires and
is composed from reversible $$3$$-bit gates. The final state generated
by the circuit&nbsp;can be written as $$x,g(x),f(x)$$, where&nbsp;$$f(x)$$ is the
final answer stored in the output register somewhere within the&nbsp;scratch
memory and $$g(x)$$&nbsp;represents ``garbage”&nbsp;(intermediate data). Here we
assumed that the scratch memory is initially clean (all zeros). Thus we
have constructed a reversible circuit&nbsp;that maps $$x,0^L$$ to
$$x,g(x),f(x)$$. The final step is&nbsp;to get rid of the garbage $$g(x)$$
without erasing any information&nbsp;(which would render the circuit
irreversible).&nbsp;A solution is to copy the answer $$f(x)$$ to a clean
ancillary register of $$m$$ bits and then ``uncompute” $$f(x)$$&nbsp;by
applying the circuit backwards in time.&nbsp;Below we sketch how this works.</p>
<p>&nbsp;<img alt="image8" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/uncomputel5yqmeuw09gam7vi.png" /></p>
<p>Ignoring for&nbsp;simplicity all ancillary bits &nbsp;that are initialized and
returned in the zero state, we obtained a reversible circuit on $$n+m$$
bits that maps input strings $$x,y$$ to output strings $$x,y\oplus
f(x)$$. In the special case when the $$f(x)$$ is invertible one can use
similar tricks to &nbsp;construct a reversible circuit that maps input
strings $$x$$ to output strings $$f(x)$$. &nbsp;In practice, one would never
use the method described above since it requires too large scratch
memory. Several optimization techniques for constructing reversible
circuits have been proposed (such as uncomputing partial results more
often and reusing scratch memory bits).</p>
</div>
<div class="section" id="quantum-circuits-for-modular-multiplication">
<h2><strong>Quantum circuits for modular multiplication</strong>.<a class="headerlink" href="#quantum-circuits-for-modular-multiplication" title="Permalink to this headline">¶</a></h2>
<p>Suppose now that &nbsp;$$f(x)=ax\pmod{N}$$ is the modular multiplication
function. Let $$n$$ be the number of binary digits in $$N$$. Using
$$n$$-bit strings to represent integers modulo $$N$$, one can implement
&nbsp;$$f(x)$$ by a classical circuit $$U_a$$ composed of 3-bit reversible
gates with $$n$$ input and output wires, as described above. The circuit
$$U_a$$ may also use ancillary bits that are initialized and returned
in the 0 state. The state-of-the-art implementation would require
roughly $$n^2$$ gates and&nbsp;roughly $$2n$$ ancillary bits. For simplicity,
below we shall often ignore the ancillary bits. &nbsp;Let us convert $$U_a$$
to a quantum circuit &nbsp;by replacing each classical gate with its quantum
counterpart. This is possible because, by construction, each gate of
$$U_a$$ implements some permutation on the set of input bit strings
$$000,001,\ldots,111$$. The corresponding quantum gate implements the
same permutation on the set of basis states
$$|000\rangle,|001\rangle,\ldots,|111\rangle$$.&nbsp;We&nbsp;obtained a
quantum circuit &nbsp;$$U_a$$ acting on a register of $$n$$ qubits that maps
a basis state $$|x\rangle$$&nbsp;to $$|f(x)\rangle$$. An example for
$$f(x)=7x\pmod{15}$$ is shown below. Period finding algorithm requires
modular multiplication circuits $$U_b$$ for
$$b=a,a^2,a^4,\ldots,a^{2^p} \pmod{N}$$, where $$2^p\approx N^2$$.</p>
<div class="line-block">
<div class="line"><img alt="image9" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-encodingo3tdoo4oaytd42t9.png" /></div>
<div class="line"><strong>some basis states representing integers modulo $$15$$</strong></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="line-block">
<div class="line"><img alt="image10" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/shor-u79r0hm5m0hot21emi.png" /></div>
<div class="line"><strong>Modular multiplication operator &nbsp;maps $$|x\rangle$$ to $$|7x
\pmod{15}\rangle$$</strong></div>
</div>
<p>&nbsp; &nbsp;This quantum circuit implements $$U_7$$ (see <a class="reference external" href="http://arxiv.org/abs/1202.6614">Markov and Saeedi
2012</a>)</p>
<p>&nbsp;&nbsp;<img alt="image11" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/multi7xmod159bozodtkjb9h33di.png" /></p>
</div>
<div class="section" id="controlled-operations-and-phase-estimation">
<h2><strong>﻿Controlled operations and phase estimation</strong>.﻿<a class="headerlink" href="#controlled-operations-and-phase-estimation" title="Permalink to this headline">¶</a></h2>
<p>Let $$U=U_a$$ be the modular multiplication operator.&nbsp;At this point we
know how to construct a quantum circuit implementing&nbsp;$$U$$ as well as
repeated squares of $$U$$ such as $$U^2,U^4,U^8$$, etc. &nbsp;We also know
that eigenvalues of $$U$$ reveal information about the period of $$a$$
modulo $$N$$. The final step is to measure the eigenvalues. For that we
shall need a controlled version of $$U$$.&nbsp;A controlled unitary operator
is a quantum analogue of classical conditional statements such as
if-then-else.&nbsp;We already saw examples of controlled quantum
gates<a class="reference external" href="/qstage/#/tutorial?sectionId=8443c4f713521c10b1a56a533958286b&amp;pageIndex=1">earlier in the
tutorial</a>.&nbsp;In
general, suppose $$U$$ is a quantum circuit acting on $$n$$ qubits.&nbsp;A
controlled version of $$U$$ &nbsp;is a unitary operator acting on a larger
system&nbsp;control+target, where control is a single qubit and target is a
register of $$n$$ qubits.&nbsp;Controlled-$$U$$ applies $$U$$ to the target
register if the control qubit is <span class="math">\(|1\rangle\)</span>&nbsp;state and does nothing
if the control qubit is <span class="math">\(|0\rangle\)</span>.</p>
<div class="line-block">
<div class="line"><img alt="image12" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/cont18osk7q79jzx8byb9.png" /></div>
<div class="line">Like their classical counterparts, controlled quantum operations are
used in almost any quantum algorithm.&nbsp;We note that if $$U$$ can be
realized by a short quantum circuit then so does
controlled-$$U$$.&nbsp;Indeed, one can take the circuit realizing $$U$$ and
replace each gate by its controlled version (with the same control
qubit).&nbsp;The main distinction from the classical if-then-else construct
&nbsp;is that the controlled qubit can be in a superposition of state
$$\alpha|0\rangle +\beta|1\rangle$$.&nbsp;One could say that in the
quantum world two branches of a conditional statement can be executed
“at the same time”. &nbsp;Consider now a special case when the target
register is prepared in some&nbsp;state $$\psi$$ which is an eigenvector
of &nbsp;$$U$$, that is $$U|\psi\rangle=e^{i\phi}
|\psi\rangle$$.&nbsp;Then the only difference between the two branches
of the controlled-$$U$$ operation&nbsp;is the phase shift $$e^{i\phi}$$.
In other words, the control qubit gets mapped from
&nbsp;$$\alpha|0\rangle+\beta|1\rangle$$ to $$\alpha|0\rangle
+e^{i\phi}\beta |1\rangle$$, while&nbsp;the target register remains in
the state $$\psi$$.&nbsp;Thus we can describe that the action of
controlled-$$U$$ on the composite&nbsp;system control+target by a
single-qubit phase shift gate $$P$$&nbsp;acting on the control qubit.</div>
</div>
<div class="line-block">
<div class="line"><img alt="image13" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/cont22hp10kmu28146lxr.png" /></div>
</div>
<p>Below we focus on what happens with the control qubit only (keeping in
mind&nbsp;that it is part of the larger system control+target). &nbsp;We shall
measure the eigenvalue $e^{i\phi}$ using a pair of phase estimation
circuits&nbsp;shown below.</p>
<div class="line-block">
<div class="line"><img alt="image14" src="https://dal.objectstorage.open.softlayer.com/v1/AUTH_039c3bf6e6e54d76b8e66152e2f87877/images-classroom/pejy6u84yb7ucpiudi.png" /></div>
</div>
<div class="line-block">
<div class="line">One can easily check that the probability of observing the measurement
outcome $$0$$&nbsp;is $$0.5(1+\cos{(\phi)})$$ for the first circuit and
$$0.5(1-\sin{(\phi)})$$ for the second circuit. &nbsp;One should keep in
mind that $$P$$ represents the controlled-$$U$$ operator, so the
circuit extracts information about the phase $$\phi$$ by measuring
interference between two branches of controlled-$$U$$ where one branch
accumulates a phase factor $$e^{i\phi}$$ and the other branch
accumulates no phase. By repeating each circuit several time and
collecting the measurement statistics we&nbsp;can estimate the
probabilities which gives us an estimate $$\phi$$.&nbsp;For concreteness,
assume that we are willing to perform at most 100 measurements.&nbsp;Then
the statistical error in our estimate of $$\phi$$ is roughly 10%.</div>
<div class="line">To factor a number $$N$$ with 1,000 decimal digits the phase $$\phi$$
has to be estimated with a very high precision $$\epsilon \sim 1/N^2
\sim 10^{-2000}$$.&nbsp;To this end we shall perform the phase estimation
for a family of unitary operators $$U^t$$, where&nbsp;$$t=1,2,4,8$$ etc. We
stop at $$t=2^p$$ such that $$2^p\approx 1/\epsilon$$. Recall that
we can efficiently implement $$U^t$$ for very large values of $$t$$
&nbsp;by classically computing $$b=a^{t}\pmod{N}$$ and using the identity
$$U^t=(U_a)^t=U_b$$. Since all operators $$U^t$$ have the same
eigenvector $$\psi$$, we can do all phase estimations&nbsp;with the same
target register (initialized in the eigenvector
$$|\psi\rangle$$).&nbsp;For simplicity, let us assume that the phase
estimations are performed sequentially&nbsp;in which case only one control
qubit is needed.&nbsp;The controlled-$$U^2$$ operator gives rise to a phase
shift $$P^2$$ by angle $$2\phi$$&nbsp;on the control qubit. Thus we can
estimate $$2\phi$$ with a precision 10% &nbsp;by performing roughly 100
measurements. This gives an estimate of $$\phi$$ &nbsp;with&nbsp;a precision
5%. &nbsp;More precisely, since the phase $$\phi$$ lives on the unit
circuit, we get a pair of candidate angles $$\phi’$$ and
$$\phi’‘=\phi’+\pi$$ such that one of them approximates $$\phi$$
with a precision 5% and the other is very far from $$\phi$$
(approximately by:math:<cite>pi</cite>). &nbsp;However, we have already estimated
$$\phi$$ itself with a precision 10%. This is enough to select one of
the candidate angles $$\phi’$$ and $$\phi’‘$$. Applying this
argument inductively several times shows that estimating
&nbsp;$$\phi,2\phi,\ldots,2^p\phi$$ with a constant precision (say,
10%) is enough to estimate&nbsp;$$\phi$$ with a precision roughly
$$2^{-p}\sim \epsilon$$. Overall we would need&nbsp;approximately
$$M=100\log_2{(1/\epsilon)}\sim 10^6$$ measurements which
translates&nbsp;to $$10^6$$ controlled modular multiplication operators. In
general, $$M$$ scales as $$\log{(N)}$$ with some extra factors doubly
logarithmic in $$N$$. Since each controlled modular multiplication
operator requires a quantum circuit of size $$\log^2{(N)}$$, the
overall complexity of the factoring algorithm scales as
$$\log^3{(N)}\sim d^3$$.</div>
</div>
<p>We have not explained yet how to initialize the target register in the
eigenvector of $$U$$. Fortunately, all eigenvectors are equally good for
our purposes: we are not interested in any particular eigenvalue &nbsp;but
rather want to measure a random eigenvalue drawn from the uniform
distribution. Thus one can initialize the target register in an
arbitrary state that has equal weight on each eigenvector of $$U$$. For
example, one can choose the initial state as the basis vector
$$|0\ldots01\rangle$$ encoding the integer $$x=1$$.</p>
<div class="section" id="id8">
<h3><a href="#id6"><span class="problematic" id="id7">**</span></a><a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
</div>


        </div>
          
    </div>
</div>
<footer class="footer">
    <div class="container">
        <p class="pull-right">
            <a href="#">Back to top</a> 
        </p>
        <p> &copy;
            Copyright 2017, IBM Research, Jim Challenger, Andrew Cross, Ismael Faro, Jay Gambetta, Jesus Perez, and John Smolin.<br/> Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.3.<br/>
        </p>
    </div>
</footer>
</body>

</html>